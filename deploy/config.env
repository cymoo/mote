# 部署配置文件
# 这个文件会被所有脚本引用

# 部署根目录
export DEPLOY_ROOT=/opt/mote

# 项目根目录 (当前脚本所在目录的上级目录)
export PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# 应用名称
export APP_NAME=mote

# 应用用户(运行服务的系统用户)
export APP_USER=mote

# 服务端口配置
export BACKEND_PORT=8000
export FRONTEND_PORT=80

# Nginx配置
# export NGINX_WORKER_PROCESSES=auto
# export NGINX_WORKER_CONNECTIONS=1024


export API_DIR="${DEPLOY_ROOT}/api"

export WEB_DIR="${DEPLOY_ROOT}/web"

export DATA_DIR="${DEPLOY_ROOT}/data"

# 配置文件目录
export CONFIG_DIR="${DEPLOY_ROOT}/config"

# 上传文件目录
export UPLOADS_DIR="${DEPLOY_ROOT}/uploads"

# 数据库配置
export DB_PATH="${DATA_DIR}/app.db"

# 应用URL路径配置
export MEMO_URL="/memo"
export BLOG_URL="/shared"

# 日志级别
export LOG_LEVEL=info

# 备份目录
export BACKUP_DIR="${DEPLOY_ROOT}/backups"

# 颜色输出
export COLOR_RESET='\033[0m'
export COLOR_RED='\033[0;31m'
export COLOR_GREEN='\033[0;32m'
export COLOR_YELLOW='\033[0;33m'
export COLOR_BLUE='\033[0;34m'

# 打印函数
log_info() {
    echo -e "${COLOR_BLUE}[INFO]${COLOR_RESET} $1"
}

log_success() {
    echo -e "${COLOR_GREEN}[SUCCESS]${COLOR_RESET} $1"
}

log_warn() {
    echo -e "${COLOR_YELLOW}[WARN]${COLOR_RESET} $1"
}

log_error() {
    echo -e "${COLOR_RED}[ERROR]${COLOR_RESET} $1"
}

# 创建目录结构
create_directories() {
    log_info "创建项目目录结构..."

    mkdir -p ${DEPLOY_ROOT}
    mkdir -p ${API_DIR}
    mkdir -p ${WEB_DIR}
    mkdir -p ${DATA_DIR}
    mkdir -p ${UPLOADS_DIR}
    mkdir -p ${CONFIG_DIR}/nginx
    mkdir -p ${CONFIG_DIR}/systemd

    # 设置权限
    chown -R ${DEPLOY_USER}:${DEPLOY_USER} ${PROJECT_DIR}
    chmod 755 ${PROJECT_DIR}
    chmod 750 ${CONFIG_DIR}

    log_success "目录结构创建完成"
}

# 检查是否为root用户
check_root() {
    if [ "$EUID" -eq 0 ]; then
        log_error "请不要使用root用户运行此脚本"
        exit 1
    fi
}

# 验证当前用户不是 root（用于需要避免特权执行的场景）
check_not_root() {
    if [ "$EUID" -eq 0 ]; then
        log_error "此脚本不应使用 root 权限执行"
        exit 1
    fi
}

# 验证当前用户是 root（用于需要特权执行的场景）
check_must_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "此脚本必须使用 root 权限执行"
        exit 1
    fi
}

# 检查命令是否存在
check_command() {
    if ! command -v "$1" &> /dev/null; then
        return 1
    fi
    return 0
}
